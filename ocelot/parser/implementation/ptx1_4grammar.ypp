/*!
	\file ptxgrammar.ypp
	\author Gregory Diamos <gregory.diamos@gatech.edu>
	\date Sunday January 18, 2009
	\brief The YACC grammar file for PTX
*/

%{
	
	#include <iostream>
	#include <ocelot/parser/interface/PTXParser.h>
	#include <FlexLexer.h>
	#include <ocelot/parser/interface/PTXLexer.h>
	#include <hydrazine/implementation/debug.h>
	#include <cassert>
	#include <cstring>

	#ifdef REPORT_BASE
	#undef REPORT_BASE
	#endif

	#define REPORT_BASE 1

	namespace ptx1_4
	{
	
	int yylex( YYSTYPE* token, YYLTYPE* location, parser::PTXLexer& lexer );
	void yyerror( YYLTYPE* location, parser::PTXLexer& lexer, 
		parser::PTXParser::State& state, char const* message );
	
	std::string yyTypeToString( int );
	
%}

%union
{
	char text[1024];
	long long int value;
	long long unsigned int uvalue;

	double doubleFloat;
	float singleFloat;
}

%parse-param {parser::PTXLexer& lexer}
%parse-param {parser::PTXParser::State& state}
%lex-param {parser::PTXLexer& lexer}
%pure-parser

%token<text> TOKEN_SPECIAL_REGISTER TOKEN_LABEL TOKEN_IDENTIFIER TOKEN_STRING
%token<text> TOKEN_INV_PREDICATE_IDENTIFIER TOKEN_PREDICATE_IDENTIFIER
%token<text> TOKEN_COMPLETE_FILE TOKEN_CLOCK

%token<text> OPCODE_COS OPCODE_SQRT OPCODE_ADD OPCODE_RSQRT OPCODE_ADDC
%token<text> OPCODE_MUL OPCODE_SAD OPCODE_SUB OPCODE_EX2 OPCODE_LG2
%token<text> OPCODE_RCP OPCODE_SIN OPCODE_REM OPCODE_MUL24 OPCODE_MAD24
%token<text> OPCODE_DIV OPCODE_ABS OPCODE_NEG OPCODE_MIN OPCODE_MAX
%token<text> OPCODE_MAD OPCODE_SET OPCODE_SETP OPCODE_SELP OPCODE_SLCT
%token<text> OPCODE_MOV OPCODE_ST OPCODE_CVT OPCODE_AND OPCODE_XOR OPCODE_OR
%token<text> OPCODE_BRA OPCODE_CALL OPCODE_RET OPCODE_EXIT OPCODE_TRAP 
%token<text> OPCODE_BRKPT OPCODE_SUBC OPCODE_TEX OPCODE_LD OPCODE_BARSYNC 
%token<text> OPCODE_ATOM OPCODE_RED OPCODE_NOT OPCODE_CNOT OPCODE_VOTE
%token<text> OPCODE_SHR OPCODE_SHL
%token<text> OPCODE_FMA OPCODE_MEMBAR OPCODE_PMEVENT

%token<value> PREPROCESSOR_INCLUDE PREPROCESSOR_DEFINE PREPROCESSOR_IF 
%token<value> PREPROCESSOR_IFDEF PREPROCESSOR_ELSE PREPROCESSOR_ENDIF 
%token<value> PREPROCESSOR_LINE PREPROCESSOR_FILE

%token<value> TOKEN_ENTRY TOKEN_EXTERN TOKEN_FILE TOKEN_VISIBLE TOKEN_LOC
%token<value> TOKEN_FUNCTION TOKEN_STRUCT TOKEN_UNION TOKEN_TARGET TOKEN_VERSION
%token<value> TOKEN_SECTION

%token<value> TOKEN_CONST TOKEN_GLOBAL TOKEN_LOCAL TOKEN_PARAM TOKEN_REG
%token<value> TOKEN_SHARED TOKEN_SREG TOKEN_TEX TOKEN_SURF TOKEN_CTA

%token<value> TOKEN_U32 TOKEN_S32 TOKEN_S8 TOKEN_S16 TOKEN_S64 TOKEN_U8 
%token<value> TOKEN_U16 TOKEN_U64 TOKEN_B8 TOKEN_B16 TOKEN_B32 TOKEN_B64 
%token<value> TOKEN_F16 TOKEN_F64 TOKEN_F32 TOKEN_PRED

%token<value> TOKEN_EQ TOKEN_NE TOKEN_LT TOKEN_LE TOKEN_GT TOKEN_GE
%token<value> TOKEN_LS TOKEN_HS TOKEN_EQU TOKEN_NEU TOKEN_LTU TOKEN_LEU
%token<value> TOKEN_GTU TOKEN_GEU TOKEN_NUM TOKEN_NAN

%token<value> TOKEN_HI TOKEN_LO TOKEN_AND TOKEN_OR TOKEN_XOR
%token<value> TOKEN_RN TOKEN_RM TOKEN_RZ TOKEN_RP TOKEN_SAT TOKEN_VOLATILE
%token<value> TOKEN_UNI TOKEN_ALIGN TOKEN_BYTE TOKEN_WIDE TOKEN_CARRY
%token<value> TOKEN_RNI TOKEN_RMI TOKEN_RZI TOKEN_RPI
%token<value> TOKEN_FTZ TOKEN_APPROX TOKEN_FULL

%token<value> TOKEN_V2 TOKEN_V4

%token<value> TOKEN_ANY TOKEN_ALL

%token<value> TOKEN_MIN TOKEN_MAX TOKEN_DEC TOKEN_INC TOKEN_ADD TOKEN_CAS
%token<value> TOKEN_EXCH

%token<value> TOKEN_1D TOKEN_2D TOKEN_3D

%token<value> TOKEN_DECIMAL_CONSTANT

%token<uvalue> TOKEN_UNSIGNED_DECIMAL_CONSTANT

%token<singleFloat> TOKEN_SINGLE_CONSTANT

%token<doubleFloat> TOKEN_DOUBLE_CONSTANT

%start statements

%%

statements : statement | statements statement;

statement : version | target | registerDeclaration | fileDeclaration | entry | 
	initializableDeclaration | uninitializableDeclaration | unsupported;

version : TOKEN_VERSION TOKEN_DOUBLE_CONSTANT
{
	report( "  Rule: VERSION DOUBLE_CONSTANT" );

	std::stringstream stream1;
	stream1 << $<doubleFloat>2;
	std::string value;
	
	stream1 >> value;
	
	std::stringstream stream2;
	std::string::iterator fi = value.begin();
	
	for( ; fi != value.end(); ++fi )
	{
		if( *fi == '.' )
		{
			++fi;
			break;
		}
		stream2 << *fi;
	}
	
	
	if( fi == value.end() )
	{
		std::stringstream error;
		error << parser::PTXParser::toString( @2, state ) 
			<< "Malformed version number " << value;
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::MalformedVersion;
		exception.message = error.str();
		throw exception;		
	}
	
	state.statement.directive = ir::PTXStatement::Version;
	stream2 >> state.statement.major;
	
	std::stringstream stream3;
	
	for( ; fi != value.end(); ++fi )
	{
		stream3 << *fi;
	}
	
	if( stream3.str().empty() )
	{
		std::stringstream error;
		error << parser::PTXParser::toString( @2, state ) 
			<< "Malformed version number " << value;
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::MalformedVersion;
		exception.message = error.str();
		throw exception;		
	}
	
	stream3 >> state.statement.minor;
	state.statement.section_type = state.sectionType;
	state.statement.section_name = state.sectionName;
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
	
	if( state.statement.minor != 4 || state.statement.major != 1 )
	{
		std::stringstream error;
		error << "Cannot parse PTX version " << state.statement.major 
			<< "." << state.statement.minor << " with version 1.4 parser.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NotVersion1_4;
		exception.message = error.str();
		throw exception;
	}
};

identifierList : identifier
{
	report( "  Rule: IDENTIFIER" );
	state.identifiers.clear();
	report( "   Appending " << $<text>1 << " to list." );
	state.identifiers.push_back( $<text>1 );
};

identifierList : identifierList ',' identifier
{
	report( "  Rule: identifierList , IDENTIFIER" );

	report( "   Appending " << $<text>3 << " to list." );
	state.identifiers.push_back( $<text>3 );
};

decimalListSingle : TOKEN_DECIMAL_CONSTANT
{
	report( "  Rule: DECIMAL_CONSTANT" );
	
	if( state.statement.array.stride.empty() )
	{
	
		state.statement.array.stride.push_back( 1 );
	}
	
	report( "   Appending " << $<value>1 << " to decimal list.");
	ir::PTXStatement::Data data;
	data.s64 = $<value>1;
	state.statement.array.values.push_back( data );
};

decimalListSingle : decimalListSingle ',' TOKEN_DECIMAL_CONSTANT
{
	report( "  Rule: decimalList ',' DECIMAL_CONSTANT" );
	
	report( "   Appending " << $<value>3 << " to decimal list.");
	ir::PTXStatement::Data data;
	data.s64 = $<value>3;
	state.statement.array.values.push_back( data );
};

decimalList : '{' decimalList '}' ',' '{' decimalList '}';
decimalList : '{' decimalListSingle '}' ',' '{' decimalListSingle '}';

decimalInitializer : decimalList | '{' decimalList '}' | 
	'{' decimalListSingle '}' | decimalListSingle;

floatListSingle : TOKEN_DOUBLE_CONSTANT
{
	report( "  Rule: DOUBLE_CONSTANT" );
	
	if( state.statement.array.stride.empty() )
	{
	
		state.statement.array.stride.push_back( 1 );
	}
	
	report( "   Appending " << $<doubleFloat>1 << " to float list.");
	ir::PTXStatement::Data data;
	data.f64 = $<doubleFloat>1;

	state.statement.array.values.push_back( data );
};

floatListSingle : floatListSingle ',' TOKEN_DOUBLE_CONSTANT
{
	report( "  Rule: floatList ',' DOUBLE_CONSTANT" );
	
	report( "   Appending " << $<doubleFloat>3 << " to float list.");
	ir::PTXStatement::Data data;
	data.f64 = $<doubleFloat>3;
	state.statement.array.values.push_back( data );
};

floatList : '{' floatList '}' ',' '{' floatList '}';
floatList : '{' floatListSingle '}' ',' '{' floatListSingle '}';

floatInitializer : floatList |  '{' floatList '}' | '{' floatListSingle '}' 
	| floatListSingle;

singleListSingle : TOKEN_SINGLE_CONSTANT
{
	report( "  Rule: DOUBLE_CONSTANT" );
	
	if( state.statement.array.stride.empty() )
	{
		state.statement.array.stride.push_back( 1 );
	}
	
	report( "   Appending " << $<singleFloat>1 << " to single list.");
	ir::PTXStatement::Data data;
	data.f64 = $<singleFloat>1;
	state.statement.array.values.push_back( data );
};

singleListSingle : singleListSingle ',' TOKEN_SINGLE_CONSTANT
{
	report( "  Rule: singleList ',' SINGLE_CONSTANT" );
	
	report( "   Appending " << $<singleFloat>3 << " to single list.");
	ir::PTXStatement::Data data;
	data.f64 = $<singleFloat>3;
	state.statement.array.values.push_back( data );
};

singleList : '{' singleList '}' ',' '{' singleList '}';
singleList : '{' singleListSingle '}' ',' '{' singleListSingle '}';

singleInitializer : singleList |  '{' singleList '}' | '{' singleListSingle '}' 
	| singleListSingle;

target : TOKEN_TARGET identifierList
{
	report( "  Rule: TARGET identifierList" );
	
	state.statement.directive = ir::PTXStatement::Target;
	state.statement.targets.assign ( state.identifiers.begin(), 
		state.identifiers.end() );
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

addressSpace : TOKEN_REG
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::Reg;
};

addressSpace : TOKEN_SREG
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::SReg;
};

addressSpace : TOKEN_CONST
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::Const;
};

addressSpace : TOKEN_GLOBAL
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::Global;
};

addressSpace : TOKEN_LOCAL
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::Local;
};

addressSpace : TOKEN_PARAM
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::Param;
};

addressSpace : TOKEN_SHARED
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::Shared;
};

addressSpace : TOKEN_TEX
{
	state.statement.instruction.addressSpace = ir::PTXInstruction::Texture;
};

dataTypeId : TOKEN_U8 | TOKEN_U16 | TOKEN_U32 | TOKEN_U64 | TOKEN_S8 
	| TOKEN_S16 | TOKEN_S32 | TOKEN_S64 | TOKEN_B8 | TOKEN_B16 | TOKEN_B32 
	| TOKEN_B64 | TOKEN_F16 | TOKEN_F32 | TOKEN_F64 | TOKEN_PRED;

dataType : dataTypeId
{
	state.operand.type = parser::PTXParser::tokenToDataType( $<value>1 );
};
	
vectorType : TOKEN_V2
{
	report( "  Switching to V2" );
	state.statement.instruction.vec = ir::PTXOperand::v2;
};

vectorType : TOKEN_V4
{
	report( "  Switching to V4" );
	state.statement.instruction.vec = ir::PTXOperand::v4;
};

alignment : TOKEN_ALIGN TOKEN_DECIMAL_CONSTANT
{
	state.alignment = $<value>2;
};

addressableVariablePrefix : dataType vectorType
{
	state.alignment = 1;
};

addressableVariablePrefix : vectorType dataType
{
	state.alignment = 1;
};

addressableVariablePrefix : dataType
{
	report( "  Switching to V1" );
	state.alignment = 1;
	state.statement.instruction.vec = ir::PTXOperand::v1;
};

addressableVariablePrefix : alignment dataType vectorType;
addressableVariablePrefix : alignment vectorType dataType;
addressableVariablePrefix : dataType alignment vectorType;
addressableVariablePrefix : dataType vectorType alignment;

addressableVariablePrefix : vectorType dataType alignment;
addressableVariablePrefix : vectorType alignment dataType;

addressableVariablePrefix : dataType alignment
{
	report( "  Switching to V1" );
	state.statement.instruction.vec = ir::PTXOperand::v1;
};

addressableVariablePrefix : alignment dataType
{
	
	report( "  Switching to V1" );
	state.statement.instruction.vec = ir::PTXOperand::v1;
};

arrayDimensionSet : '[' TOKEN_DECIMAL_CONSTANT ']'
{
	report( "  Rule: '[' DECIMAL_CONSTANT ']'" );

	state.statement.array.stride.clear();

	if( $<value>2 <= 0 )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @2, state ) 
			<< "Invalid array dimension " << $<value>2;
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::MalformedVersion;
		exception.message = error.str();
		throw exception;
	}
	
	report( "   Got dimension " << $<value>2 );
	state.statement.array.stride.push_back( (unsigned int) $<value>2 );
};

arrayDimensionSet : arrayDimensionSet '[' TOKEN_DECIMAL_CONSTANT ']'
{
	report( "  Rule: arrayDimensions '[' DECIMAL_CONSTANT ']'" );

	if( $<value>3 <= 0 )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @3, state ) 
			<< "Invalid array dimension " << $<value>3;
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidVecType;
		exception.message = error.str();
		throw exception;
	}
	
	report( "   Got dimension " << $<value>3 );
	state.statement.array.stride.push_back( (unsigned int) $<value>3 );	
};

arrayDimensionSet : '[' ']'
{
	report( "  Rule: arrayDimensions '[' ']'" );
	state.statement.array.stride.clear();
	
	report( "   Got dimension " << 0 );
	state.statement.array.stride.push_back( 0 );	
};

arrayDimensions : /* empty string */
{
	state.statement.array.stride.clear();
};

arrayDimensions : arrayDimensionSet;

initializer : /* empty string */;

assignment : '='
{
	report( "  Clearing doubles" );
	state.statement.array.values.clear();
};

initializer : assignment decimalInitializer | assignment floatInitializer 
	| assignment singleInitializer;

registerDeclaration : TOKEN_REG dataType identifier ';'
{
	report( "  Rule: REG dataType IDENTIFIER ';'" );

	state.statement.directive = ir::PTXStatement::Reg;
	state.statement.type = state.operand.type;
	state.statement.name = $<text>3;
	state.statement.array.vec = ir::PTXOperand::v1;
	state.statement.attribute = ir::PTXStatement::NoAttribute;
	
	if( state.operand.type == ir::PTXOperand::pred )
	{
	
		state.operand.condition = ir::PTXOperand::Pred;
	}
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	state.statement.array.stride.resize(1);
	state.statement.array.stride[0] = 1;

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
	
	if( state.operands.count( state.statement.name ) != 0 ) 
	{
	
			std::stringstream error;
			error << parser::PTXParser::toString( @3, state ) 
				<< "Variable name " << state.statement.name 
				<< " already declared in this scope.";
			parser::PTXParser::Exception exception;
			exception.error = parser::PTXParser::State::DuplicateDeclaration;
			exception.message = error.str();
			throw exception;
			}

	state.operand.addressMode = ir::PTXOperand::Register;
	state.operand.identifier = state.statement.name;
	state.operand.vec = ir::PTXOperand::v1;

	state.operands.insert( std::make_pair( state.statement.name, 
		state.operand ) );
	};

registerDeclaration : TOKEN_REG dataType identifier 
	'<' TOKEN_DECIMAL_CONSTANT '>' ';'
{
	report( "  Rule: REG dataType IDENTIFIER '<' DECIMAL_CONSTANT '>' ';'" );

	state.statement.directive = ir::PTXStatement::Reg;
	state.statement.type = state.operand.type;
	state.statement.name = $<text>3;
	state.statement.array.vec = ir::PTXOperand::v1;
	state.statement.attribute = ir::PTXStatement::NoAttribute;
	
	if( state.operand.type == ir::PTXOperand::pred )
	{
	
		state.operand.condition = ir::PTXOperand::Pred;
	}
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	state.statement.array.stride.resize(1);
	state.statement.array.stride[0] = $<value>5;

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
	state.operand.addressMode = ir::PTXOperand::Register;
	state.operand.vec = ir::PTXOperand::v1;

	for( unsigned int i = 0; i < state.statement.array.stride[0]; ++i )
	{
	
		std::stringstream name;
		name << state.statement.name << i;
	
		if( state.operands.count( name.str() ) != 0 ) 
		{
	
			std::stringstream error;
			error << parser::PTXParser::toString( @3, state ) 
				<< "Variable name " << name.str() 
				<< " already declared in this scope.";
			parser::PTXParser::Exception exception;
			exception.error = parser::PTXParser::State::DuplicateDeclaration;
			exception.message = error.str();
			throw exception;
			
		}

		state.operand.identifier = name.str();

		state.operands.insert( std::make_pair( name.str(), 
			state.operand ) );
		
		if( state.inEntry )
		{
		
			state.localOperands.push_back( name.str() );
		
		}
				}
};

fileDeclaration : TOKEN_COMPLETE_FILE
{
	report( "  Rule: COMPLETE_FILE" );

	state.statement.directive = ir::PTXStatement::File;
	state.statement.name = $<text>1;
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

initializableDeclaration : initializable addressableVariablePrefix 
	identifier arrayDimensions initializer ';'
{
	report( "  Rule: initializable addressableVariablePrefix IDENTIFIER " 
		<< "arrayDimensions initializer';'" );

	assert( state.directive == ir::PTXStatement::Const 
		|| state.directive == ir::PTXStatement::Global 
		|| state.directive == ir::PTXStatement::Tex );

	state.statement.directive = state.directive;
	report( "   Name = " << $<text>3 );
	state.statement.name = $<text>3;
	state.statement.alignment = state.alignment;
	state.statement.array.vec = state.statement.instruction.vec;
	state.statement.type = state.operand.type;
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	// correct for single precision
	if( state.statement.type == ir::PTXOperand::f32 )
	{
		for( ir::PTXStatement::ArrayVector::iterator 
			fi = state.statement.array.values.begin();
			fi != state.statement.array.values.end(); ++fi )
		{
			fi->f32 = fi->f64;			

		}	

	}
	
	if( state.statement.array.values.size() != 0 )
	{
	
		unsigned int expected = 0;
	
		for( ir::PTXStatement::ArrayStrideVector::iterator 
			fi = state.statement.array.stride.begin(); 
			fi != state.statement.array.stride.end(); ++fi )
		{
	
			expected += *fi;
	
		}
		
		if( state.statement.array.vec == ir::PTXOperand::v2 )
		{
		
			expected *= 2;
		
		} 
		else if( state.statement.array.vec == ir::PTXOperand::v4 )
		{
		
			expected *= 4;
		
		}
		
		if( expected != state.statement.array.values.size() )
		{
	
			std::stringstream error;
			error << parser::PTXParser::toString( @5, state ) 
				<< "Array size " << expected 
				<< " does not match initializer size " 
				<< state.statement.array.values.size();
			parser::PTXParser::Exception exception;
			exception.error = parser::PTXParser::State::InitializerSizeMismatch;
			exception.message = error.str();
			throw exception;
	
		}
		}
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );		

	if( state.operands.count( state.statement.name ) != 0 ) 
	{
		std::stringstream error;
		error << parser::PTXParser::toString( @3, state ) 
			<< "Variable name " << state.statement.name 
			<< " already declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::DuplicateDeclaration;
		exception.message = error.str();
		throw exception;
	}

	state.operand.identifier = state.statement.name;

	state.operands.insert( std::make_pair( 
		state.statement.name, state.operand ) );
	
	if( state.inEntry )
	{
		state.localOperands.push_back( state.statement.name );
	}
	
	state.statement.array.stride.clear();
	state.statement.array.values.clear();
};

parameterList : parameterDeclaration | parameterList ',' parameterDeclaration
{
	report( "  Hit rule parameterDeclaration | parameterList " 
		<< "',' parameterDeclaration" );
};

entry : TOKEN_ENTRY identifier '(' parameterList ')' '{' 
{
	report( "  Half Rule: ENTRY IDENTIFIER '(' parameterList ')' '{'" );

	state.statement.directive = ir::PTXStatement::Entry;
	state.statement.name = $<text>2;
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );		

	state.statement.directive = ir::PTXStatement::StartEntry;
	
	state.statement.line = @3.first_line;
	state.statement.column = @3.first_column;
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
	
	state.inEntry = true;	

} 
entryDeclarations '}'
{
	report( "  Rule: ENTRY IDENTIFIER '{' entryDeclarations '}'" );

	state.statement.directive = ir::PTXStatement::EndEntry;
	
	state.statement.line = @5.first_line;
	state.statement.column = @5.first_column;
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
	
	state.inEntry = false;
	
	for( parser::PTXParser::State::StringList::iterator 
		operand = state.localOperands.begin(); 
		operand != state.localOperands.end(); ++operand )
	{
	
		parser::PTXParser::State::OperandMap::iterator 
			fi = state.operands.find( *operand );
		assert( fi != state.operands.end() );
	
		state.operands.erase( fi );
	}
	
	state.localOperands.clear();
};

instruction : basicInstruction2 | basicInstruction3 | branch | addOrSub 
	| addCOrSubC | atom | bar | brkpt | cvt | div | exit | ld | mad | mad24 
	| mov | mul24 | mul | red | ret | selp | set | setp | slct | st | tex 
	| trap | vote;

entryDeclaration : registerDeclaration | uninitializableDeclaration | location 
	| label;

entryDeclaration : guard instruction
{
	report( "  Rule: guard instruction" );
	
	// check for an error
	assert( !state.module.statements.empty() );
	assert( state.module.statements.back().directive 
		== ir::PTXStatement::Instr );
	
	std::string message = 
		state.module.statements.back().instruction.valid();
	
	if( message != "" )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @2, state ) 
			<< "Parsed invalid instruction " 
			<< state.module.statements.back().instruction.toString();
		error << ": " << message;
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidInstruction;
		exception.message = error.str();
		throw exception;
	}
	
	state.operandVector.clear();
};

entryDeclarations : entryDeclaration;

entryDeclarations : entryDeclarations entryDeclaration;

externOrVisible : TOKEN_EXTERN
{
	state.statement.attribute = ir::PTXStatement::Extern;
};

externOrVisible : TOKEN_VISIBLE
{
	state.statement.attribute = ir::PTXStatement::Visible;
};

externOrVisible : /* empty string */
{
	state.statement.attribute = ir::PTXStatement::NoAttribute;
};

parameter : externOrVisible TOKEN_PARAM
{
	report( "Hit rule : externOrVisible TOKEN_PARAM" );
	state.directive = ir::PTXStatement::Param;
	state.operand.addressMode = ir::PTXOperand::Address;
	state.operand.offset = 0;
};

uninitializable : externOrVisible TOKEN_LOCAL
{
	state.directive = ir::PTXStatement::Local;
	state.operand.addressMode = ir::PTXOperand::Address;
	state.operand.offset = 0;
};

uninitializable : externOrVisible TOKEN_SHARED
{
	state.directive = ir::PTXStatement::Shared;
	state.operand.addressMode = ir::PTXOperand::Address;
	state.operand.offset = 0;
};

initializable : externOrVisible TOKEN_CONST
{
	state.directive = ir::PTXStatement::Const;
	state.operand.addressMode = ir::PTXOperand::Address;
	state.operand.offset = 0;
};

initializable : externOrVisible TOKEN_TEX
{
	state.directive = ir::PTXStatement::Tex;
	state.operand.addressMode = ir::PTXOperand::Address;
	state.operand.offset = 0;
};

initializable : externOrVisible TOKEN_GLOBAL
{
	state.directive = ir::PTXStatement::Global;
	state.operand.addressMode = ir::PTXOperand::Address;
	state.operand.offset = 0;
};

opcode : OPCODE_COS | OPCODE_SQRT | OPCODE_ADD | OPCODE_RSQRT | OPCODE_ADDC
	| OPCODE_MUL | OPCODE_SAD | OPCODE_SUB | OPCODE_EX2 | OPCODE_LG2
	| OPCODE_RCP | OPCODE_SIN | OPCODE_REM | OPCODE_MUL24 | OPCODE_MAD24
	| OPCODE_DIV | OPCODE_ABS | OPCODE_NEG | OPCODE_MIN | OPCODE_MAX
	| OPCODE_MAD | OPCODE_SET | OPCODE_SETP | OPCODE_SELP | OPCODE_SLCT
	| OPCODE_MOV | OPCODE_ST | OPCODE_CVT | OPCODE_AND | OPCODE_XOR | OPCODE_OR
	| OPCODE_BRA | OPCODE_CALL | OPCODE_RET | OPCODE_EXIT | OPCODE_TRAP 
	| OPCODE_BRKPT | OPCODE_SUBC | OPCODE_TEX | OPCODE_LD | OPCODE_BARSYNC 
	| OPCODE_ATOM | OPCODE_RED | OPCODE_NOT | OPCODE_CNOT | OPCODE_VOTE
	| OPCODE_SHR | OPCODE_SHL;

identifier : '_' | TOKEN_IDENTIFIER | opcode;

uninitializableDeclaration : uninitializable addressableVariablePrefix 
	identifier arrayDimensions ';'
{
	report( "  Rule: uninitializable addressableVariablePrefix IDENTIFIER " 
		<< "arrayDimensions';'" );

	assert( state.directive == ir::PTXStatement::Param || 
		state.directive == ir::PTXStatement::Local ||
		state.directive == ir::PTXStatement::Shared );

	state.statement.directive = state.directive;
	state.statement.name = $<text>3;
	state.statement.alignment = state.alignment;
	state.statement.array.vec = state.statement.instruction.vec;
	state.statement.type = state.operand.type;
	state.statement.array.stride.assign( state.statement.array.stride.begin(), 
		state.statement.array.stride.end() );
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );		

	state.operand.identifier = state.statement.name;
	
	state.operands.insert( std::make_pair( 
		state.statement.name, state.operand ) );
		
	if( state.inEntry )
	{
		state.localOperands.push_back( state.statement.name );
	}
};

parameterDeclaration : parameter addressableVariablePrefix 
	identifier arrayDimensions
{
	report( "  Rule: parameter addressableVariablePrefix identifier " 
		<< "arrayDimensions';'" );

	assert( state.directive == ir::PTXStatement::Param );

	state.statement.directive = state.directive;
	state.statement.name = $<text>3;
	state.statement.alignment = state.alignment;
	state.statement.array.vec = state.statement.instruction.vec;
	state.statement.type = state.operand.type;
	state.statement.array.stride.assign( state.statement.array.stride.begin(), 
		state.statement.array.stride.end() );
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );		

	state.operand.identifier = state.statement.name;
	
	state.operands.insert( std::make_pair( 
		state.statement.name, state.operand ) );
		
	if( state.inEntry )
	{
		state.localOperands.push_back( state.statement.name );
	}
};


location : TOKEN_LOC TOKEN_DECIMAL_CONSTANT TOKEN_DECIMAL_CONSTANT 
	TOKEN_DECIMAL_CONSTANT
{
	report( "  Rule: LOC DECIMAL_CONSTANT DECIMAL_CONSTANT DECIMAL_CONSTANT" );

	std::stringstream stream;
	
	stream << $<value>2 << " " << $<value>3 << " " << $<value>4;

	state.statement.directive = ir::PTXStatement::Loc;
	state.statement.name = stream.str();
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );		
};

label : TOKEN_LABEL
{
	report( "  Rule: LABEL" );

	state.statement.directive = ir::PTXStatement::Label;
	state.statement.name = $<text>1;
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );		
};

labelOperand : identifier
{
	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>1 );
	
	if( mode == state.operands.end() )
	{
	
		state.operand.identifier = $<text>1;
		state.operand.addressMode = ir::PTXOperand::Label;
		state.operand.type = ir::PTXOperand::TypeSpecifier_invalid;
	}
	else
	{
		state.operand = mode->second;
	}
	
	state.operandVector.push_back( state.operand );
};

nonLabelOperand : identifier
{
	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>1 );
	
	if( mode == state.operands.end() )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Operand " << $<text>1
			<< " not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}
	else
	{
		state.operand = mode->second;
	}
	
	state.operandVector.push_back( state.operand );
};

baseOperand : TOKEN_DECIMAL_CONSTANT
{
	state.operand.addressMode = ir::PTXOperand::Immediate;
	state.operand.imm_int = $<value>1;
	state.operand.vec = ir::PTXOperand::v1;
	state.operand.type = 
		parser::PTXParser::smallestType( state.operand.imm_int );
	
	state.operandVector.push_back( state.operand );
};

baseOperand : TOKEN_UNSIGNED_DECIMAL_CONSTANT
{
	state.operand.addressMode = ir::PTXOperand::Immediate;
	state.operand.imm_int = $<uvalue>1;
	state.operand.vec = ir::PTXOperand::v1;
	state.operand.type = 
		parser::PTXParser::smallestType( state.operand.imm_uint );
	
	state.operandVector.push_back( state.operand );
};

baseOperand : TOKEN_DOUBLE_CONSTANT
{
	state.operand.addressMode = ir::PTXOperand::Immediate;
	state.operand.imm_float = $<doubleFloat>1;
	state.operand.vec = ir::PTXOperand::v1;
	state.operand.type = ir::PTXOperand::f64;
	
	state.operandVector.push_back( state.operand );
};

baseOperand : TOKEN_SINGLE_CONSTANT
{
	state.operand.addressMode = ir::PTXOperand::Immediate;
	state.operand.imm_float = $<singleFloat>1;
	state.operand.vec = ir::PTXOperand::v1;
	state.operand.type = ir::PTXOperand::f32;
	
	state.operandVector.push_back( state.operand );
};

baseOperand : TOKEN_CLOCK
{
	state.operand.addressMode = ir::PTXOperand::Special;
	state.operand.identifier = $<text>1;
	state.operand.type = ir::PTXOperand::u32;
	state.operand.special = parser::PTXParser::stringToSpecial( $<text>1 );
	state.operand.vec = ir::PTXOperand::v1;
	
	state.operandVector.push_back( state.operand );	
};

baseOperand : TOKEN_SPECIAL_REGISTER
{
	state.operand.addressMode = ir::PTXOperand::Special;
	state.operand.identifier = $<text>1;
	state.operand.type = ir::PTXOperand::b16;
	state.operand.special = parser::PTXParser::stringToSpecial( $<text>1 );
	state.operand.vec = ir::PTXOperand::v1;
	
	state.operandVector.push_back( state.operand );	
};

operand : baseOperand | nonLabelOperand;

memoryOperand : operand;

memoryOperand : identifier '+' TOKEN_DECIMAL_CONSTANT
{
	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>1 );
	
	if( mode == state.operands.end() )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Operand " << $<text>1
			<< " not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}
	else
	{
		if( mode->second.addressMode == ir::PTXOperand::Register )
		{
		
			state.operand.addressMode = ir::PTXOperand::Indirect;
		
		}
		else
		{
		
			state.operand.addressMode = ir::PTXOperand::Address;
		
		}
	}
	
	state.operand.identifier = $<text>1;
	state.operand.vec = ir::PTXOperand::v1;
	state.operand.offset = $<value>3;
	state.operand.type = ir::PTXOperand::u64;
	
	state.operandVector.push_back( state.operand );
};

memoryOperand : identifier '-' TOKEN_DECIMAL_CONSTANT
{
	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>1 );
	
	if( mode == state.operands.end() )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Operand " << $<text>1
			<< " not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}
	else
	{
		if( mode->second.addressMode == ir::PTXOperand::Register )
		{
		
			state.operand.addressMode = ir::PTXOperand::Indirect;
		
		}
		else
		{
		
			state.operand.addressMode = ir::PTXOperand::Address;
		
		}
	}
	
	state.operand.identifier = $<text>1;
	state.operand.vec = ir::PTXOperand::v1;
	state.operand.offset = -$<value>3;
	state.operand.type = ir::PTXOperand::u64;
	
	state.operandVector.push_back( state.operand );
}; 

basicInstruction2Opcode : OPCODE_ABS | OPCODE_COS | OPCODE_CNOT | OPCODE_EX2 
	| OPCODE_LG2 | OPCODE_NEG | OPCODE_NOT | OPCODE_RCP 
	| OPCODE_RSQRT | OPCODE_SIN | OPCODE_SQRT;

guard : TOKEN_PREDICATE_IDENTIFIER
{
	report( "  Rule: PREDICATE_IDENTIFIER" );

	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>1 );
	
	if( mode == state.operands.end() )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Predicate " << $<text>1
			<< " not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}

	state.operand = mode->second;
	state.operand.condition = ir::PTXOperand::Pred;

	state.operandVector.push_back( state.operand );
};

guard : TOKEN_INV_PREDICATE_IDENTIFIER
{
	report( "  Rule: PREDICATE_IDENTIFIER" );

	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>1 );
	
	if( mode == state.operands.end() )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Predicate " << $<text>1
			<< " not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}

	state.operand = mode->second;
	state.operand.condition = ir::PTXOperand::InvPred;

	state.operandVector.push_back( state.operand );
};

guard : /* empty string */
{
	report( "  Rule: No guard predicate" );

	state.operand.addressMode = ir::PTXOperand::Register;
	state.operand.type = ir::PTXOperand::pred;
	state.operand.condition = ir::PTXOperand::PT;

	state.operandVector.push_back( state.operand );

}

basicInstruction2 : basicInstruction2Opcode dataType operand ',' operand ';'
{
	report( "  Rule: basicInstruction2Opcode '.' dataType operand ',' " 
		<< "operand ';'" );

	assert( state.operandVector.size() == 3 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>2 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );
	state.statement.instruction.modifier = 0;

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

basicInstruction3Opcode : OPCODE_AND | OPCODE_MAX | OPCODE_MIN | OPCODE_OR 
	| OPCODE_REM | OPCODE_SHL | OPCODE_SHR | OPCODE_XOR 
	| OPCODE_ADD | OPCODE_MUL | OPCODE_ADDC | OPCODE_SUB;

basicInstruction3 : basicInstruction3Opcode dataType operand ',' operand ',' 
	operand ';'
{
	report( "  Rule: basicInstruction3Opcode '.' dataType operand ',' " 
		<< "operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>2 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );
	state.statement.instruction.modifier = 0;
	state.statement.instruction.carry = ir::PTXInstruction::None;

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

branchOpcode : OPCODE_BRA | OPCODE_CALL;

branchOperand : baseOperand | labelOperand;

branch : branchOpcode branchOperand ';'
{
	report( "  Rule: branchOpcode operand ';'" );

	assert( state.operandVector.size() == 2 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.uni = false;
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

branch : OPCODE_BRA TOKEN_UNI branchOperand ';'
{
	report( "  Rule: branchOpcode TOKEN_UNI operand ';'" );

	assert( state.operandVector.size() == 2 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.uni = true;
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

addModifier : TOKEN_CARRY
{
	state.statement.instruction.carry = ir::PTXInstruction::CC; 
	state.statement.instruction.modifier = 0;

}

addModifier : TOKEN_SAT
{
	state.statement.instruction.modifier = 
		parser::PTXParser::tokenToModifier( $<value>1 );
	state.statement.instruction.carry = ir::PTXInstruction::None; 

}

addOrSubOpcode : OPCODE_ADD | OPCODE_SUB;

addOrSub : addOrSubOpcode addModifier dataType operand ',' operand ',' 
	operand ';'
{
	report( "  Rule: addOrSubOpcode addModifier1 dataType operand ',' " 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

addCModifier : TOKEN_CARRY
{
	state.statement.instruction.carry = ir::PTXInstruction::CC; 
		};

addCOrSubCOpcode : OPCODE_ADDC | OPCODE_SUBC;

addCOrSubC : addCOrSubCOpcode addCModifier dataType operand ',' operand 
	',' operand ';'
{
	report( "  Rule: addCOrSubCOpcode addCModifier dataType operand ',' " 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.modifier = 0;
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

atomicOperationId : TOKEN_AND | TOKEN_OR | TOKEN_XOR | TOKEN_CAS | TOKEN_EXCH 
	| TOKEN_ADD | TOKEN_INC | TOKEN_DEC | TOKEN_MIN | TOKEN_MAX;

atomicOperation : atomicOperationId
{
	state.statement.instruction.atomicOperation = 
		parser::PTXParser::tokenToAtomicOperation( $<value>1 );
};

atom : OPCODE_ATOM addressSpace atomicOperation dataType operand ',' '[' 
	memoryOperand ']' ',' operand ';'
{
	report( "  Rule: OPCODE_ATOM addressSpace atomicOperation dataType " 
		<< "operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>4 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c.addressMode = ir::PTXOperand::Invalid;
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );
	
	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

atom : OPCODE_ATOM addressSpace atomicOperation dataType operand ',' '[' 
	memoryOperand ']' ',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_ATOM addressSpace atomicOperation dataType " 
		<< "operand ',' operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 5 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>4 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c = state.operandVector[4];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

bar : OPCODE_BARSYNC operand ';'
{
	report( "  Rule: OPCODE_BARSYNC operand ';'" );

	assert( state.operandVector.size() == 2 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

brkpt : OPCODE_BRKPT ';'
{
	report( "  Rule: OPCODE_BRKPT ';'" );

	assert( state.operandVector.size() == 1 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

cvtModifier1 : TOKEN_RN | TOKEN_RM | TOKEN_RP | TOKEN_RZ | TOKEN_SAT 
	| TOKEN_RNI | TOKEN_RMI | TOKEN_RPI | TOKEN_RZI;

cvtModifier : /* empty string */
{
	state.statement.instruction.modifier = 0;
};

cvtModifier : cvtModifier1
{
	state.statement.instruction.modifier = 
		parser::PTXParser::tokenToModifier( $<value>1 );
};

cvtModifier : cvtModifier1 TOKEN_SAT
{
	state.statement.instruction.modifier = 
		parser::PTXParser::tokenToModifier( $<value>1 )
		| parser::PTXParser::tokenToModifier( $<value>2 );
};

cvt : OPCODE_CVT cvtModifier dataType dataType operand ',' operand ';'
{
	report( "  Rule: OPCODE_CVT cvtModifier dataType dataType operand "
		<< "',' operand ';'" );

	assert( state.operandVector.size() == 3 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.d.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	if( !ir::PTXOperand::valid( parser::PTXParser::tokenToDataType( $<value>4 ),
		 state.statement.instruction.a.type ) )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Type of " << state.statement.instruction.a.identifier << " "
			<< ir::PTXOperand::toString( state.statement.instruction.a.type ) 
			<< " not convertable to type " 
			<< ir::PTXOperand::toString( 
			parser::PTXParser::tokenToDataType( $<value>4 ) ) << " .";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidDataType;
		exception.message = error.str();
		throw exception;	
	}
	
	state.statement.instruction.a.type = 
		parser::PTXParser::tokenToDataType( $<value>4 );

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

divModifier : TOKEN_SAT
{
	state.statement.instruction.modifier = 0 | ir::PTXInstruction::sat;
};

divModifier : /* empty string */
{
	state.statement.instruction.modifier = 0;
};

div : OPCODE_DIV divModifier dataType operand ',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_DIV divModifier dataType operand ',' " 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;		

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

exit : OPCODE_EXIT ';'
{
	report( "  Rule: OPCODE_EXIT ';'" );

	assert( state.operandVector.size() == 1 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;		

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

ldModifier : TOKEN_VOLATILE addressSpace
{
	state.statement.instruction.volatility = ir::PTXInstruction::Volatile;
	state.statement.instruction.vec = ir::PTXOperand::v1;
	state.statement.instruction.addressSpace = 
		parser::PTXParser::tokenToAddressSpace( $<value>2 );
		};

ldModifier : TOKEN_VOLATILE addressSpace vectorType
{
	state.statement.instruction.volatility = ir::PTXInstruction::Volatile;
	state.statement.instruction.addressSpace = 
		parser::PTXParser::tokenToAddressSpace( $<value>2 );
		};

ldModifier : addressSpace vectorType
{
	state.statement.instruction.volatility = ir::PTXInstruction::Nonvolatile;
	state.statement.instruction.addressSpace = 
		parser::PTXParser::tokenToAddressSpace( $<value>1 );
		};

ldModifier : addressSpace
{
	state.statement.instruction.volatility = ir::PTXInstruction::Nonvolatile;
	state.statement.instruction.vec = ir::PTXOperand::v1;
	state.statement.instruction.addressSpace = 
		parser::PTXParser::tokenToAddressSpace( $<value>1 );
		};

ld : OPCODE_LD ldModifier dataType arrayOperand ',' '[' memoryOperand ']' ';'
{
	report( "  Rule: OPCODE_LD ldModifier dataType arrayOperand ',' " 
		<< " '[' memoryOperand ']' ';'" );

	assert( state.operandVector.size() == 3 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

hiOrLo : TOKEN_HI | TOKEN_LO;

roundHiLoWide : TOKEN_RN | TOKEN_RM | TOKEN_RP | TOKEN_RZ | hiOrLo | TOKEN_WIDE;

madModifier : /*empty string */
{
	state.statement.instruction.modifier = 0;
};

madModifier : mulModifier;

mulModifier : roundHiLoWide
{
	state.statement.instruction.modifier = 0 		
		| parser::PTXParser::tokenToModifier( $<value>1 );
};

mulModifier : TOKEN_SAT
{
	state.statement.instruction.modifier = 0 
		| ir::PTXInstruction::sat;
};

mulModifier : roundHiLoWide TOKEN_SAT
{
	state.statement.instruction.modifier = 0 
		| parser::PTXParser::tokenToModifier( $<value>1 ) 
		| ir::PTXInstruction::sat;
};

mad : OPCODE_MAD madModifier dataType operand ',' operand 
	',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_MAD madModifier dataType operand " 
		<< "',' operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 5 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c = state.operandVector[4];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

mad24Modifier : /* empty string */
{
	state.statement.instruction.modifier = 0;
};

mad24Modifier : hiOrLo
{
	state.statement.instruction.modifier = 0 		
		| parser::PTXParser::tokenToModifier( $<value>1 );
};

mad24Modifier : TOKEN_SAT
{
	state.statement.instruction.modifier = 0 
		| ir::PTXInstruction::sat;
};

mad24Modifier : hiOrLo TOKEN_SAT
{
	state.statement.instruction.modifier = 0 
		| parser::PTXParser::tokenToModifier( $<value>1 ) 
		| ir::PTXInstruction::sat;
};

mad24 : OPCODE_MAD24 mad24Modifier dataType operand ',' operand 
	',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_MAD24 mad24Modifier dataType operand " 
		<< "',' operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 5 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c = state.operandVector[4];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

mov : OPCODE_MOV dataType arrayOperand ',' arrayOperand ';'
{
	report( "  Rule: OPCODE_MOV '.' dataType arrayOperand ',' " 
		<< "arrayOperand ';'" );

	assert( state.operandVector.size() == 3 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>2 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );
	state.statement.instruction.modifier = 0;

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

mul24Modifier : /* empty string */
{
	state.statement.instruction.modifier = 0;
};

mul24Modifier : hiOrLo
{
	state.statement.instruction.modifier = 0 		
		| parser::PTXParser::tokenToModifier( $<value>1 );
};

mul24 : OPCODE_MUL24 mul24Modifier dataType operand ',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_MUL24 mul24Modifier dataType operand ',' " 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

mul : OPCODE_MUL mulModifier dataType operand ',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_MUL mulModifier dataType operand ',' " 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

reductionOperationId : TOKEN_AND | TOKEN_XOR | TOKEN_OR | TOKEN_ADD | TOKEN_INC
	| TOKEN_DEC | TOKEN_MIN | TOKEN_MAX;
	
reductionOperation : reductionOperationId
{
	state.statement.instruction.reductionOperation = 
		parser::PTXParser::tokenToReductionOperation( $<value>1 );
};

red : OPCODE_RED addressSpace reductionOperation dataType operand ',' 
	operand ';'
{
	report( "  Rule: OPCODE_RED addressSpace reductionOperation dataType" 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 3 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>4 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];	

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

retUni : /* empty string */
{
	state.statement.instruction.uni = false;
};

retUni : TOKEN_UNI
{
	state.statement.instruction.uni = true;
};

ret : OPCODE_RET retUni ';'
{
	report( "  Rule: OPCODE_RET retUni ';'" );

	assert( state.operandVector.size() == 2 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

comparisonId : TOKEN_EQ | TOKEN_NE | TOKEN_LT | TOKEN_LE | TOKEN_GT | TOKEN_GE
	| TOKEN_LS | TOKEN_HS | TOKEN_EQU | TOKEN_NEU | TOKEN_LTU | TOKEN_LEU
	| TOKEN_GTU | TOKEN_GEU | TOKEN_NUM | TOKEN_NAN;

comparison : comparisonId
{
	state.statement.instruction.comparisonOperator = 
		parser::PTXParser::tokenToCmpOp( $<value>1 );
};

set : OPCODE_SET comparison dataType dataType operand ',' operand ',' 
	operand ';'
{
	report( "  Rule: OPCODE_SET comparison dataType dataType operand ',' " 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c.addressMode = ir::PTXOperand::Invalid;
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );
	state.statement.instruction.booleanOperator = ir::PTXInstruction::BoolNop;

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	if( !ir::PTXOperand::valid( parser::PTXParser::tokenToDataType( $<value>4 ),
		 state.statement.instruction.a.type ) )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Type of " << state.statement.instruction.a.identifier << " "
			<< ir::PTXOperand::toString( state.statement.instruction.a.type ) 
			<< " not convertable to type " 
			<< ir::PTXOperand::toString( 
			parser::PTXParser::tokenToDataType( $<value>4 ) ) << " .";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidDataType;
		exception.message = error.str();
		throw exception;
	}

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

boolOperatorId : TOKEN_AND | TOKEN_OR | TOKEN_XOR;

boolOperator : boolOperatorId
{
	state.statement.instruction.booleanOperator = 
		parser::PTXParser::tokenToBoolOp( $<value>1 );
};

selp : OPCODE_SELP dataType operand ',' operand ',' operand ',' 
	operand ';'
{
	report( "  Rule: basicInstruction3Opcode '.' dataType operand ',' " 
		<< "operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 5 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>2 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c = state.operandVector[4];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};


set : OPCODE_SET comparison boolOperator dataType dataType operand ',' 
	operand ',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_SET comparison boolOperator dataType dataType " 
		<< " operand ',' operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 5 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>4 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c = state.operandVector[4];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	if( !ir::PTXOperand::valid( parser::PTXParser::tokenToDataType( $<value>5 ),
		 state.statement.instruction.a.type ) )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Type of " << state.statement.instruction.a.identifier << " "
			<< ir::PTXOperand::toString( state.statement.instruction.a.type ) 
			<< " not convertable to type " 
			<< ir::PTXOperand::toString( 
			parser::PTXParser::tokenToDataType( $<value>5 ) ) << " .";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidDataType;
		exception.message = error.str();
		throw exception;
	}

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

setp : OPCODE_SETP comparison dataType operand ',' operand ',' 
	operand ';'
{
	report( "  Rule: OPCODE_SET comparison dataType operand ',' " 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.pq.addressMode = ir::PTXOperand::Invalid;
	state.statement.instruction.booleanOperator = ir::PTXInstruction::BoolNop;
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c.addressMode = ir::PTXOperand::Invalid;
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

setp : OPCODE_SETP comparison boolOperator dataType operand ',' 
	operand ',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_SETP comparison boolOperator dataType " 
		<< " operand ',' operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 5 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>4 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.pq.addressMode = ir::PTXOperand::Invalid;
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c = state.operandVector[4];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

setp : OPCODE_SETP comparison boolOperator dataType operand '|' 
	operand ',' operand ',' operand ',' operand ';'
{
	report( "  Rule: OPCODE_SETP comparison boolOperator dataType " 
		<< " operand | operand ',' operand ',' operand ',' operand ';'" );

	assert( state.operandVector.size() == 6 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>4 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.pq = state.operandVector[2];
	state.statement.instruction.a = state.operandVector[3];
	state.statement.instruction.b = state.operandVector[4];
	state.statement.instruction.c = state.operandVector[5];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
}; 

slct : OPCODE_SLCT dataType dataType operand ',' operand ',' operand ',' 
	operand ';'
{
	report( "  Rule: OPCODE_SLCT dataType dataType operand ',' operand ','" 
		<< " operand ',' operand ';'" );

	assert( state.operandVector.size() == 5 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>2 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.b = state.operandVector[3];
	state.statement.instruction.c = state.operandVector[4];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	if( !ir::PTXOperand::valid( parser::PTXParser::tokenToDataType( $<value>3 ),
		 state.statement.instruction.c.type ) )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Type of " << state.statement.instruction.c.identifier << " "
			<< ir::PTXOperand::toString( state.statement.instruction.c.type ) 
			<< " not convertable to type " 
			<< ir::PTXOperand::toString( 
			parser::PTXParser::tokenToDataType( $<value>3 ) ) << " .";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidDataType;
		exception.message = error.str();
		throw exception;
	}

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

arrayOperand : operand;
arrayOperand : '{' identifierList '}'
{
	assert( !state.identifiers.empty() );

	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( state.identifiers.front() );
	
	if( state.identifiers.size() > 4 )
	{
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Array operand \"" 
			<< hydrazine::toString( state.identifiers.begin(), 
			state.identifiers.end(), "," ) 
			<< "\" has more than 4 elements.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidArray;
		exception.message = error.str();
		throw exception;
	}

	if( state.identifiers.size() == 3 )
	{
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Array operand \"" 
			<< hydrazine::toString( state.identifiers.begin(), 
			state.identifiers.end(), "," ) 
			<< "\" has exactly 3 elements.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidArray;
		exception.message = error.str();
		throw exception;
	}
	
	if( mode == state.operands.end() )
	{
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Identifier \"" << state.identifiers.front() 
			<< "\" not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}
	
	state.operand = mode->second;
	
	if( state.identifiers.size() == 1 )
	{
		state.operand.vec = ir::PTXOperand::v1;
		state.operand.array.push_back( mode->second );
	}
	else if( state.identifiers.size() >= 2 )
	{
		state.operand.vec = ir::PTXOperand::v2;
		state.operand.array.push_back( mode->second );
		
		mode = state.operands.find( state.identifiers[1] );
		
		if( mode == state.operands.end() )
		{
			std::stringstream error;
			error << parser::PTXParser::toString( @1, state ) 
				<< "Identifier \"" << state.identifiers[1]
				<< "\" not declared in this scope.";
			parser::PTXParser::Exception exception;
			exception.error = parser::PTXParser::State::NoDeclaration;
			exception.message = error.str();
			throw exception;
		}
		
		state.operand.array.push_back( mode->second );
	}
	
	if( state.identifiers.size() == 4 )
	{
	
		state.operand.vec = ir::PTXOperand::v4;
		
		mode = state.operands.find( state.identifiers[2] );
		
		if( mode == state.operands.end() )
		{
			std::stringstream error;
			error << parser::PTXParser::toString( @1, state ) 
				<< "Identifier \"" << state.identifiers[2]
				<< "\" not declared in this scope.";
			parser::PTXParser::Exception exception;
			exception.error = parser::PTXParser::State::NoDeclaration;
			exception.message = error.str();
			throw exception;
		}
		
		state.operand.array.push_back( mode->second );
		
		mode = state.operands.find( state.identifiers[3] );
		
		if( mode == state.operands.end() )
		{
			std::stringstream error;
			error << parser::PTXParser::toString( @1, state ) 
				<< "Identifier \"" << state.identifiers[3]
				<< "\" not declared in this scope.";
			parser::PTXParser::Exception exception;
			exception.error = parser::PTXParser::State::NoDeclaration;
			exception.message = error.str();
			throw exception;
		}
		
		state.operand.array.push_back( mode->second );
	}
	
	state.operandVector.push_back( state.operand );
	
	state.operand.array.clear();
};

st : OPCODE_ST ldModifier dataType '[' memoryOperand ']' ',' arrayOperand ';'
{
	report( "  Rule: OPCODE_ST ldModifier dataType '[' memoryOperand ']' ',' " 
		<< "operand ';'" );

	assert( state.operandVector.size() == 3 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>3 );
	
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

geometryId : TOKEN_1D | TOKEN_2D | TOKEN_3D;

geometry : geometryId
{
	state.statement.instruction.geometry = 
		parser::PTXParser::tokenToGeometry( $<value>1 );
};

tex : OPCODE_TEX geometry TOKEN_V4 dataType dataType arrayOperand ',' '[' 
	operand ',' arrayOperand ']' ';'
{
	report( "  Rule: OPCODE_TEX geometry TOKEN_V4 dataType dataType " 
		<< "arrayOperand ',' '[' operand ',' arrayOperand ' ']' ;'" );

	assert( state.operandVector.size() == 4 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = 
		parser::PTXParser::tokenToDataType( $<value>5 );
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.c = state.operandVector[3];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	if( !ir::PTXOperand::valid( parser::PTXParser::tokenToDataType( $<value>4 ),
		 state.statement.instruction.d.type ) )
	{
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Type of " << state.statement.instruction.d.identifier << " "
			<< ir::PTXOperand::toString( state.statement.instruction.d.type ) 
			<< " not convertable to type " 
			<< ir::PTXOperand::toString( 
			parser::PTXParser::tokenToDataType( $<value>4 ) ) << " .";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::InvalidDataType;
		exception.message = error.str();
		throw exception;
	}
	
	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );	
};

trap : OPCODE_TRAP ';'
{
	report( "  Rule: OPCODE_TRAP ';'" );

	assert( state.operandVector.size() == 1 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;		

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

voteOperationId : TOKEN_ANY | TOKEN_ALL | TOKEN_UNI;

voteOperation : voteOperationId
{
	state.statement.instruction.vote = 
		parser::PTXParser::tokenToVoteMode( $<value>1 );
};

voteOperand : identifier
{
	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>1 );
	
	if( mode == state.operands.end() )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Operand " << $<text>1
			<< " not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}
	else
	{
		state.operand = mode->second;
	}
	
	state.operand.condition = ir::PTXOperand::Pred;
	
	state.operandVector.push_back( state.operand );
};

voteOperand : '!' identifier
{
	parser::PTXParser::State::OperandMap::iterator 
		mode = state.operands.find( $<text>2 );
	
	if( mode == state.operands.end() )
	{
	
		std::stringstream error;
		error << parser::PTXParser::toString( @2, state ) 
			<< "Operand " << $<text>2
			<< " not declared in this scope.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NoDeclaration;
		exception.message = error.str();
		throw exception;
	}
	else
	{
		state.operand = mode->second;
	}
	
	state.operand.condition = ir::PTXOperand::InvPred;
	
	state.operandVector.push_back( state.operand );
};

vote : OPCODE_VOTE voteOperation TOKEN_PRED operand ',' voteOperand ';'
{
	report( "  Rule: OPCODE_VOTE voteOperation TOKEN_PRED operand ','" 
		<< " operand ';'" );

	assert( state.operandVector.size() == 3 );

	state.statement.directive = ir::PTXStatement::Instr;
	state.statement.instruction.type = ir::PTXOperand::pred;
	state.statement.instruction.pg = state.operandVector[0];
	state.statement.instruction.d = state.operandVector[1];
	state.statement.instruction.a = state.operandVector[2];
	state.statement.instruction.opcode = 
		parser::PTXParser::stringToOpcode( $<text>1 );

	state.statement.line = @1.first_line;
	state.statement.column = @1.first_column;	

	report( "   Parsed statement " << state.module.statements.size() 
		<< " \"" << state.statement.toString() << "\"" );
	state.module.statements.push_back( state.statement );
};

unsupported: TOKEN_STRUCT
{
	std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Structs not supported in this version.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NotSupported;
		exception.message = error.str();
		throw exception;
};

unsupported: TOKEN_UNION
{
	std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Unions not supported in this version.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NotSupported;
		exception.message = error.str();
		throw exception;
};

unsupported: TOKEN_FUNCTION
{
	std::stringstream error;
		error << parser::PTXParser::toString( @1, state ) 
			<< "Functions not supported in this version.";
		parser::PTXParser::Exception exception;
		exception.error = parser::PTXParser::State::NotSupported;
		exception.message = error.str();
		throw exception;
};

%%

int yylex( YYSTYPE* token, YYLTYPE* location, parser::PTXLexer& lexer )
{
	lexer.yylval = token;
	
	int tokenValue = lexer.yylexPosition();
	location->first_line = lexer.lineno();
	location->first_column = lexer.column;
	
	report( " Lexer (" << location->first_line << "," << location->first_column 
		<< "): " << parser::PTXLexer::toString( tokenValue ) << " \"" 
		<< lexer.YYText() << "\"" );
	
	return tokenValue;

}

void yyerror( YYLTYPE* location, parser::PTXLexer& lexer, 
	parser::PTXParser::State& state, char const* message )
{
	parser::PTXParser::Exception exception;
	std::stringstream stream;
	stream << parser::PTXParser::toString( *location, state ) 
		<< "Syntax error, could not match any rule for \"" << lexer.YYText() 
		<< "\"";
	exception.message = stream.str();
	exception.error = parser::PTXParser::State::SyntaxError;
	throw exception;

}

}

